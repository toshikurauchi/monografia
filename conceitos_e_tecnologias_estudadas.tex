\section{Conceitos e tecnologias estudadas}
A seguir serão apresentados os conceitos e tecnologias utilizadas na implementação da engine, assim como na aplicação de exemplo (visualização de campos tensoriais).

% Separar em \section{Conceitos} e \section{} 
% Codigos indentados \minipage 
% site springer templates -> caixa cinza no fundo
% Verificar as referencias (tem algumas com ? ainda)
% Cuidado com as referencias (ou deixar espaço (~) ou não em todos)
% Cuidado com o tamanho dos codigos (esta passando da margem)
% c++ -> C++
% Transformações lineares -> transformações de geometria ou algo assim
% Verificar todas as funcoes pra colocar \texttt
% Codigos grandes em apendices
% Diminuir o numero de subsubsections: juntar se for muito pequeno, colocar só bold ao inves de subsubsection
% Replicar só o que for essencial do codigo
% Tentar deixar o texto menos pesado e segmentado
% Ser mais descritivo nos captions
% Juntar referencias da janela (msdn)
% Bibliografia -> atencao para padronizacao e letras maiusculas tem um truquezinho (abre e fecha alguma coisa)
% Terminar todos os captions com .

\subsection{Linguagem C++98}
A linguagem de programação C++ foi desenvolvida como uma evolução da linguagem C. Por esse motivo a sintaxe de ambas é semelhante e um código escrito em C é válido em C++. É uma linguagem estruturada que, entre outras características, adiciona o paradigma de orientação a objetos ao C.

\subsubsection{Variáveis e funções}
As variáveis e funções são declaradas com a mesma sintaxe utilizada na linguagem C (um tipo seguido de um nome, podendo receber um valor inicial):

\begin{verbatim}
<tipo> <nome> [= <valor inicial>]
\end{verbatim}

Ou seja, para declarar uma variável inteira chamada \texttt{contador} com valor inicial zero é utilizada a seguinte sintaxe:

\begin{verbatim}
int contador = 0;
\end{verbatim}

\subsubsection{Classes e objetos}
Classes são definidas pelas palavras reservadas \texttt{class} ou \texttt{struct}, sendo que a diferença entre elas é o fato de atributos de uma \texttt{class} serem privados por padrão e os de uma \texttt{struct}, públicos. É possível adicionar modificadores de acesso através das palavras \texttt{public}, \texttt{private} e \texttt{protected} que definem acesso livre em todos os escopos, acesso restrito à classe e acesso restrito à classe e suas subclasses respectivamente. Construtores são declarados como funções com o nome da classe sem valor e tipo de retorno. A declaração de uma classe \texttt{Coordenada2d} poderia ocorrer das seguintes maneiras:

Utilizando \texttt{class}:

\begin{verbatim}
class Coordenada2d {
public:
    Coordenada2d(double x, double y);
private:
    double x,y;
};
\end{verbatim}

Utilizando \texttt{struct}:

\begin{verbatim}
struct Coordenada2d {
    double x,y;
};
\end{verbatim}

Para se instanciar um objeto existem duas opções. A primeira consiste em declarar uma variável da classe desejada (da mesma forma como variáveis do tipo \texttt{int} são declaradas, por exemplo). Na declaração da variável a classe será instanciada e inicializada. A segunda maneira é a utilização da palavra reservada \texttt{new} seguida do nome da classe. O valor devolvido é um ponteiro para uma instância da classe desejada. Seguindo o exemplo anterior, a classe Coordenada2d poderia ser instanciada das seguintes formas:

\begin{verbatim}
Coordenada2d coordenada1;
Coordenada2d * coordenada2 = new Coordenada2d;
\end{verbatim}

Os argumentos do construtor são passados da seguinte maneira:

\begin{verbatim}
Coordenada2d coordenada1(1.0, 2.0);
Coordenada2d * coordenada2 = new Coordenada2d(1.0, 2.0);
\end{verbatim}

\subsubsection{Namespaces}
Para evitar colisão de identificadores como nomes de classes, variáveis e funções é possível utilizar um \texttt{namespace}:

\begin{verbatim}
namespace nome {
// Entidades
    int n;
}
\end{verbatim}

Onde \texttt{nome} é qualquer identificador válido e \texttt{Entidades} é o conjunto de classes, variáveis e funções que ficarão protegidas dentro de um \texttt{namespace}.

Para referenciar identificadores de um \texttt{namespace} é utilizada a seguinte sintaxe:

\begin{verbatim}
<nome do namespace>::<identificador>
\end{verbatim}

Para acessar a variável \texttt{n} do exemplo utiliza-se o seguinte código:

\begin{verbatim}
nome::n
\end{verbatim}

\subsubsection{Templates}
O template é um recurso da linguagem C++ que permite programação genérica. É utilizado para a implementação de funções ou classes cujas funcionalidades podem ser adaptadas para tipos diferentes com o mesmo código. Para isso é utilizada a palavra reservada \texttt{template} seguida por um parâmetro de template, que é um tipo especial de parâmetro que pode ser utilizado para enviar tipos como argumento.

Uma função \texttt{maximo} poderia ser definida da seguinte maneira:

\begin{verbatim}
template <class T>
T maximo(T a, T b) {
    T resultado;
    resultado = (a > b) ? a : b;
    return resultado;
}
\end{verbatim}

Para utilizá-la deve ser enviado o tipo dos argumentos utilizados:

\begin{verbatim}
int c = 4, d = 5;
maximo<int>(c,d);
\end{verbatim}

Um nó de uma lista ligada genérica poderia ser implementado de maneira análoga:

\begin{verbatim}
template <class T>
class No {
public:
    No(T valorInicial) {
        valor = valorInicial;
        proximo = NULL;
    }
    T getValor() {
        return valor;
    }
    void setValor(T novoValor) {
        valor = novoValor;
    }
    No<T> * getProximo() {
        return proximo;
    }
    void setProximo(No<T> *novoProximo) {
        proximo = novoProximo;
    }
private:
    T valor;
    No<T> *proximo;
};
\end{verbatim}

A utilização também é análoga à de funções:

\begin{verbatim}
No<int> meuNo(5);
\end{verbatim}

\subsubsection{A Standard Template Library (STL)}

A Standard Template Library (STL)~\cite{stl}é uma biblioteca C++ baseada em templates que oferece um conjunto de algoritmos e estruturas de dados configuráveis.

É possível, por exemplo, aplicar uma função para todos os itens de um vetor de inteiros da seguinte maneira:

\begin{verbatim}
void imprime(int i) {
    printf("%d ", i);
}

int main() {
    std::vector<int> vetor;
    // Adicionando os valores 1, 2 e 3 no vetor
    vetor.push_back(1);
    vetor.push_back(2);
    vetor.push_back(3);

    for_each(vetor.begin(), vetor.end(), imprime);
    // Saída: 1 2 3

    return 0;
}
\end{verbatim}

O método \texttt{for\_each} pode, alternativamente, receber um objeto com a função a ser aplicada a cada item da lista definida na sobrescrita do operador \texttt{()} como a seguir:

\begin{verbatim}
struct impressor {
    void operator() (int i) {
        printf("%d ", i);
    }
} meuImpressor;

int main() {
    std::vector<int> vetor;
    vetor.push_back(1);
    vetor.push_back(2);
    vetor.push_back(3);

    for_each(vetor.begin(), vetor.end(), meuImpressor);
    // Saída: 1 2 3

    return 0;
}
\end{verbatim}

Há diversos outros tipos de algoritmos implementados na STL~\cite{algorithm}

\subsection{Boost C++ Libraries}

Boost~\cite{boost} é uma biblioteca de C++ de código aberto inicialmente desenvolvida como uma extensão para a STL sob o namespace \texttt{boost}. Os principais módulos dessa biblioteca utilizados no desenvolvimento da engine foram \texttt{bind}, \texttt{function} e \texttt{smart\_ptr}. 

O módulo \texttt{function} cria functors (objetos de função) que são capazes de armazenar tanto funções nativas da linguagem quanto outros functors. Essas funções são criadas através da seguinte construção:

\begin{verbatim}
void f (int i, int j, int k) {
    // implementação
}
// boost::function[numero de argumentos]<tipo de retorno, tipos dos argumentos>
boost::function3<void,int,int,int> funcao = f;
\end{verbatim}

A biblioteca \texttt{bind} cria functors (classes que implementam o método \texttt{operator ()}) a partir de uma função ou outro functor mas com alguns argumentos já posicionados, por exemplo:

\begin{verbatim}
boost::bind(f, 1, _1, _2)
\end{verbatim}

Nesse caso boost::bind cria um functor que recebe apenas dois argumentos, indicados pelos nomes \_1 e \_2, o primeiro e o segundo argumento do functor criado respectivamente.

As funcionalidades de bind e function podem ser combinadas:

\begin{verbatim}
// functor sem retorno que recebe dois argumentos inteiros
boost::function2<void, int, int> functor1 = boost::bind(f, 1, _1, _2);
// cria um boost::function a partir do resultado do boost::bind de uma 
// boost::function
boost::function1<void, int> functor2 = boost::bind(functor1, 2, _1);
\end{verbatim}

Os módulos bind e function da boost são utilizados principalmente em conjunto com algoritmos da STL, como o std::for\_each. %TODO: exemplo de código?

Os \texttt{smart\_ptr} são classes que guardam ponteiros para áreas de memória alocadas dinamicamente. Essas classes tem comportamento semelhante ao de ponteiros nativos da linguagem, com a diferença de que elas desalocam o recurso a que referenciam em momento adequado. Existem seis tipos \texttt{smart\_ptr} definidos:

\begin{itemize}
\item \texttt{scoped\_ptr}: representa o conceito de ponteiro não compartilhável, logo não podem ser copiados. Desalocam a memória ao sair de escopo.
\item \texttt{scoped\_array}: mesmo que \texttt{scoped\_ptr} mas para um array de objetos.
\item \texttt{shared\_ptr}: representa um ponteiro que tem diversos donos, pode ser copiado e só é destruído quando todos os donos forem destruídos.
\item \texttt{shared\_array}: mesmo que \texttt{shared\_ptr} mas para arrays.
\item \texttt{weak\_ptr}: são ponteiros para recursos de um \texttt{shared\_ptr} mas que não são donos do recurso.
\item \texttt{intrusive\_ptr}: são \texttt{shared\_ptr} que guardam dentro do objeto para o qual apontam o contador de referências utilizado internamente.
\end{itemize}

\subsection{OpenGL}

O OpenGL é uma API gráfica amplamente adotada no mercado. Ele é uma especificação aberta e extensível~\cite{openglregistry} de uma interface de software para o hardware gráfico.

\subsubsection{O que ele não faz}

O OpenGL não realiza tratamentos que dependam do sistema operacional, ou seja, não gerencia janelas, nem controla eventos de entrada e saída.

Além disso ele não disponibiliza nenhuma forma de leitura de arquivos. Por esse motivo, não é possível visualizar diretamente imagens guardadas em arquivos (como png, jpg, bmp, ou modelos em três dimensões como 3ds\cite{3dsfileformat}, blend\cite{blendfileformat}, ou obj\cite{objfileformat}).

\subsubsection{O que ele faz}

O OpenGL é capaz de representar vértices em três dimensões combinados em pontos, retas, triângulos e quadriláteros, chamados de primitivas.

Tais primitivas são projetadas em um plano e transformadas em conjuntos de pixels. Essa transformação, conhecida como rasterização é parte do processo descrito a seguir.

% O caption da imagem esta cobrindo o texto (diminuir a imagem)

\begin{wrapfigure}{r}{0.4\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.4\textwidth]{pipeline}
\end{center}
\vspace{-20pt}
\caption{Pipeline}
\vspace{-40pt}
\end{wrapfigure}

\subsubsection{O pipeline}

As primitivas geradas na CPU (Central Processing Unit) são enviadas para a GPU (Graphics Processing Unit) onde serão processadas e utilizadas para gerar uma imagem que será mostrada na janela. Esse processo é dividido em 5 estágios principais.

No primeiro são aplicadas as transformações lineares e necessárias nos vértices (vertex shader). Em seguida as primitivas são subdivididas em partículas menores e podem ser gerados novos vértices (tessellation shaders e geometry shader). Por fim os vértices em 3 dimensões são projetados em um plano (rasterização) que representa a tela resultando em pixels que por sua vez passam por um processamento final (fragment shader), após a execução do fragment shader, os pixels passam pelo teste de profundidade, onde é determinado se o pixel é visível, se o pixel passar no teste, o valor de sua profundidade é gravado no depth buffer e o pixel é escrito no framebuffer, senão, os valores gerados pelo fragment shader são descartados. Esse processo é conhecido como pipeline.

No OpenGL todos esses processos (com exceção da rasterização) são customizáveis, entretanto na Pandora's Box somente o vertex shader e o fragment shader podem ser modificados. Mais detalhes são apresentados na seção~\ref{atividades}.

\subsubsection{O contexto do OpenGL}

O OpenGL é implementado internamente como uma máquina de estados. Tais estados, assim como outras informações, como a janela e texturas são guardados em um contexto, que deve ser criado e inicializado para o funcionamento da aplicação. Essa criação é dependente da plataforma e por esse motivo não está definida na API do OpenGL.

\subsection{GLEW}

A \texttt{OpenGL Extension Wrangler Library}  \cite{glew}, conhecida como \texttt{GLEW} é uma biblioteca que auxilia no gerenciamento de extensões do OpenGL. Ela define constantes em tempo de execução contendo as extensões suportadas pelo sistema do usuário e, além disso, obtém as novas funções definidas. % Acho que não entendi esse ultimo pedaço

O uso da \texttt{GLEW} é ilustrado no código abaixo:

\begin{verbatim}
#include <GL/glew.h>
// Após a inicialização do contexto do OpenGL
glewInit();
// após a inicialização as funções definidas através de extensões estão
// disponíveis

// verificar se a extensão GL_ARB_vertex_program está disponível
if(GLEW_ARB_vertex_program) {
    ...
}
// ou
if(glewIsSupported("GL_ARB_vertex_program")) {

}
\end{verbatim}

\subsection{Windows API~\cite{msdn}}
Como citado anteriormente, o OpenGL não é responsável por criar janelas e tratar eventos gerados pelo sistema operacional, esse tratamento é dependente do ambiente no qual o programa será executado. Nesse trabalho foi utilizada apenas a API do sistema operacional Windows.

Para se inicializar um contexto para a execução de programas em OpenGL é necessário criar uma janela, para isso usa-se a seguinte função:

\begin{verbatim}
HWND WINAPI CreateWindow(
  __in_opt  LPCTSTR lpClassName,
  __in_opt  LPCTSTR lpWindowName,
  __in      DWORD dwStyle,
  __in      int x,
  __in      int y,
  __in      int nWidth,
  __in      int nHeight,
  __in_opt  HWND hWndParent,
  __in_opt  HMENU hMenu,
  __in_opt  HINSTANCE hInstance,
  __in_opt  LPVOID lpParam
);
\end{verbatim}

Onde:
\begin{itemize}
\item \texttt{lpClassName}: representa uma classe registrada anteriormente no sistema.
\item \texttt{lpWindowName}: representa o título da janela.
\item \texttt{dwStyle}: conjunto de flags que definem como a janela será exibida\cite{docwindowstyle}: com bordas, maximizada, minimizada, etc.
\item \texttt{x, y}: posição inicial da janela.
\item \texttt{nWidth, nHeight}: dimensões iniciais da janela.
\item \texttt{hWndParent}: se a janela que está sendo criada é uma subjanela de uma já existente, passa-se o handle (tipo especial de ponteiro inteligente) da janela pai nesse argumento, caso contrário, passa-se \texttt{NULL}. Para a engine gráfica, esse argumento sempre recebe o valor \texttt{NULL}.
\item \texttt{hMenu}: se for necessário criar uma menu, deve-se passar o handle do menu nesse argumento, caso contrário, passa-se \texttt{NULL}.
\item \texttt{hInstance}: o handle da instância do programa que está sendo executado, esse parâmetro é utilizado dentro do sistema na criação de um identificador único para a janela.
\item \texttt{lpParam}: dados do usuário. Esse parâmetro recebe um ponteiro para qualquer tipo de dado que o usuário necessite. Na engine esse argumento recebe o ponteiro para uma instância de uma classe interna que representa a janela do sistema.
\end{itemize}

Para se registrar uma classe no sistema deve-se chamar a função\cite{docregisterclass}:
\begin{verbatim}
ATOM WINAPI RegisterClass(
  __in  const WNDCLASS *lpWndClass
);
\end{verbatim}

O argumento \texttt{lpWndClass} um ponteiro para uma instância de \texttt{WNDCLASS}\cite{docwndclass}, uma estrutura que guarda, entre outras coisas, o nome da classe que está sendo registrada, o ponteiro para a função que irá tratar os eventos gerados pelo sistema e uma flag que indica se o contexto do dispositivo\cite{docdevicecontext} pode ser compartilhado. Quando se cria um contexto do OpenGL é importante sempre registrar a classe como dona do contexto do dispositivo. %TODO: Por que isso?

Após criada, deve-se avisar o sistema que a janela é visível, para isso, executa-se:

\begin{verbatim}
BOOL WINAPI ShowWindow(
  __in  HWND hWnd,
  __in  int nCmdShow
);
\end{verbatim}

Onde \texttt{hWnd} é o handle devolvido pela função \texttt{CreateWindow} e \texttt{nCmdShow} controla como a janela deve ser exibida (maximizada, minimizada, simplesmente exibida, etc)

% TODO: Em nenhum lugar foi citado que o trabalho é dividido em threads
Depois de criar a janela, a thread mãe começa a receber os eventos da janela criada em sua fila de mensagens. Para se recuperar uma mensagem da fila, utiliza-se a função:

\begin{verbatim}
BOOL WINAPI GetMessage(
  __out     LPMSG lpMsg,
  __in_opt  HWND hWnd,
  __in      UINT wMsgFilterMin,
  __in      UINT wMsgFilterMax
);
\end{verbatim}

Que recebe como parâmetros um ponteiro para uma estrutura do tipo \texttt{MSG}\cite{docmsg}, o handle devolvido pela função \texttt{CreateWindow}, \texttt{wMsgFilterMin} e \texttt{wMsgFilterMax} são constantes que podem ser passadas para indicar que tipo de mensagem deve ser retornada. O valor de retorno dessa função é um inteiro que indica qual o tipo de mensagem foi retornada ou se ocorreu um erro durante a execução da função.

Após recuperar a mensagem ela precisa ser traduzida e em seguida enviada para o seu destino final. A função responsável pela tradução da mensagem é:

\begin{verbatim}
BOOL WINAPI TranslateMessage(
  __in  const MSG *lpMsg
);
\end{verbatim}

e a função que envia a mensagem para a janela é:

\begin{verbatim}
LRESULT WINAPI DispatchMessage(
  __in  const MSG *lpmsg
);
\end{verbatim}

Quando a thread principal recebe a mensagem \texttt{WM\_QUIT}, o retorno de \texttt{GetMessage} é \texttt{0}, nesse momento a tradução e envio de mensagens deve parar e o programa deve apagar o registro da classe criada por \texttt{RegisterClass}. O registro é apagado pela função:

\begin{verbatim}
BOOL WINAPI UnregisterClass(
  __in      LPCTSTR lpClassName,
  __in_opt  HINSTANCE hInstance
);
\end{verbatim}

que recebe como argumentos o nome com o qual a classe foi registrada e a instância do programa que registrou a classe.

\subsubsection{O loop de eventos da janela}

A função registrada na WNDCLASS que tratará os eventos gerados pelo sistema deve ter a seguinte assinatura:
\begin{verbatim}
LRESULT CALLBACK WindowProc(
  __in  HWND hwnd,
  __in  UINT uMsg,
  __in  WPARAM wParam,
  __in  LPARAM lParam
);
\end{verbatim}

Nessa função, o argumento hwnd é o handle da janela corrente, uMsg é um inteiro sem sinal que codifica a mensagem recebida e os argumentos wParam e lParam são os parâmetros da mensagem.

Por exemplo:
% falar sobre window resize...

Um laço de eventos típico para um programa em OpenGL tem a seguinte forma:

\begin{verbatim}
LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
	switch(msg) {
		case WM_CREATE: 
			// Inicialização do contexto de renderização
			// no caso da WM_CREATE o valor de lParam é um ponteiro para um struct
			// do tipo CREATESTRUCT que contém o ponteiro para os dados do usuário
			// passado na função CreateWindow
			
		case WM_DESTROY:
			// Liberação de recursos gráficos e deleção do contexto criado
		case WM_CLOSE:
			// O usuário clicou no botão de fechamento da janela
			// Então deve-se avisar para o sistema operacional que a aplicação deve
			// ser encerrada.
			PostQuitMessage(0);
			break;
		case WM_PAINT:
			// O sistema requisitou à aplicação a atualização da janela

			// Funções do OpenGL para limpar e renderizar
			wglSwapBuffers();
			// avisa ao sistema que o evento já foi completamente tratado
			return 0;
	}
	// Executa a rotina padrão para tratar o evento gerado
	return (DefWindowProc(hwnd, msg, wParam, lParam));
}
\end{verbatim}

Ao receber \texttt{WM\_CREATE} a aplicação deve inicializar todos os recursos para que a janela possa ser utilizada. No caso da Pandora's Box utilizando OpenGL como API gráfica, deve-se inicializar o contexto de renderização que será utilizado.

% antes de chamarmos wglCreateContext devemos criar o pixel format descriptor
A criação do contexto é gerenciada pela API do wgl (também conhecido como Wiggle), que é a implementação de OpenGL para o Windows. O contexto que será utilizado pela aplicação deve ser criado através da função wglCreateContext:

% assinatura da wglCreateContext
\begin{verbatim}
\end{verbatim}

Essa função tem como argumento o handle para o dispositivo utilizado pela janela. Tal handle pode ser obtido através da função GetDC:

% outro prototipo
% Verificar se precisa do prototipo ou tirar o : anterior

Logo a criação do contexto pode ser feita pelo seguinte trecho de código:

\begin{verbatim}
case WM_CREATE:
	HDC hDC = GetDC(hWnd);
	setPixelFormatDescriptor();
	HGLRC hglrc = wglCreateContext(hDC);
	wglMakeCurrent(hglrc);
	break;
\end{verbatim}

\subsection{Carregamento dinâmico de DLL}

Para que seja possível suportar diversas implementações independentes de especificações de APIs gráficas, a engine possui um mecanismo de carregamento dinâmico de DLLs.

Para se executar código presente em uma DLL, é necessário carregá-la durante a execução do programa. Através da windows API, pode-se abrir um arquivo DLL com a função \texttt{LoadLibrary}:

\begin{verbatim}
% protótipo da load library
\end{verbatim}

essa função retorna o handle para a biblioteca carregada ou NULL caso tenha ocorrido um erro. Caso o carregamento seja bem sucedido, pode-se utilizar o handle obtido para procurar ponteiro de funções.

Na windows API, a função que cuida da busca de ponteiros de função é a GetProcAddress

\begin{verbatim}
% protótipo da get proc address
\end{verbatim}

essa função devolve um ponteiro genérico do tipo void* que precisa ser transformado para um ponteiro de função.

% Verificar esse paragrafo (explicar melhor, ligar com o resto)
O carregamento de uma DLL dynamic\_create.dll com uma função chamada create é exemplificado no código abaixo:

\begin{verbatim}
// função que não recebe argumentos e retorna um ponteiro genérico
typedef void * (__cdecl * MYPROC)();

HINSTANCE lib = LoadLibrary(L"dynamic_create.dll");
MYPROC lib_create = (MYPROC)GetProcAddress(lib, L"create");
SomeObject object = (SomeObject) lib_create();
\end{verbatim}

Um detalhe importante do carregamento dinâmico de bibliotecas escritas em C++, é que para permitir o uso de namespaces, classes e sobrecarga de funções, o compilador da linguagem muda os nomes das funções geradas. Logo se uma função chamada create for compilada como um procedimento de C++, seu nome no arquivo dll não será create, mas sim um nome que depende da implementação do compilador utilizado. Para evitar a mudança de nomes, as funções a serem exportadas devem ser declaradas da forma abaixo:

\begin{verbatim}
extern "C" {
	// declaração das funções a serem exportadas.
}
\end{verbatim}

Outro detalhe específico do compilador da Microsoft, que foi utilizado nesse trabalho, é que os procedimentos que serão exportados devem ser definidos com a diretiva da seguinte forma:
\begin{verbatim}
__declspec(dllexport) TipoDeRetorno nome_da_funcao(parametros);
\end{verbatim}

\subsection{Transformações lineares}
O conceito de transformações lineares é de importância fundamental para a computação gráfica. Através delas é possível representar translações, rotações e escalas aplicadas sobre os objetos.

% TIrar essa definicao
\subsubsection{Definição}
Sejam $U$ e $V$ espaços vetoriais. Uma transformação linear é uma aplicação~\cite{callioli2007algebra} $F: U \rightarrow V$, tal que:
\begin{enumerate}
\item $F(u_1 + u_2) = F(u_1) + F(u_2), \forall u_1, u_2 \in U$
\item $F(\alpha u) = \alpha F(u), \forall \alpha \in \mathbb{R}$ e $\forall u \in U$
\end{enumerate}

% Tirar o titulo dessa subsecao
\subsubsection{Aplicação em computação gráfica}
Em computação gráfica são utilizadas as coordenadas homogêneas~\cite{redbook} de vértices em $\mathbb{R}^3$. Para realizar a translação, rotação e escala de objetos representados em tais coordenadas utiliza-se as seguintes matrizes de transformação linear:

Translação:

% Fazer isso um item

\begin{math}
\left(
\begin{array}{cccc}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 
\end{array}
\right)
\end{math}

Onde $t_x, t_y, t_z$ são as translações nos eixos $x, y, z$ respectivamente.

Rotação no eixo x:

\begin{math}
\left(
\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & cos\theta & -sen\theta & 0 \\
0 & sen\theta & cos\theta & 0 \\
0 & 0 & 0 & 1 
\end{array}
\right)
\end{math}

Rotação no eixo y:

\begin{math}
\left(
\begin{array}{cccc}
cos\theta & 0 & sen\theta & 0 \\
0 & 1 & 0 & 0 \\
-sen\theta & 0 & cos\theta & 0 \\
0 & 0 & 0 & 1 
\end{array}
\right)
\end{math}

Rotação no eixo z:

\begin{math}
\left(
\begin{array}{cccc}
cos\theta & -sen\theta & 0 & 0 \\
sen\theta & cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 
\end{array}
\right)
\end{math}

Onde $\theta$ é o ângulo de rotação.

Escala:

\begin{math}
\left(
\begin{array}{cccc}
s_x & 0 & 0 & 0 \\
0 & s_y & 0 & 0 \\
0 & 0 & s_z & 0 \\
0 & 0 & 0 & 1 
\end{array}
\right)
\end{math}

Onde $s_x, s_y, s_z$ são as escalas aplicadas nos eixos $x, y, z$ respectivamente.

As transformações podem ser compostas através de multiplicações das matrizes.

\subsection{Tensores de imagens de ressonância magnética de difusão}

Difusão é o nome dado ao movimento aleatório de moléculas em um fluido (líquido ou gasoso). Denomina-se coeficiente de difusão a facilidade com que uma molécula se move no meio. Em fluidos homogêneos, como a água, o coeficiente de difusão é o mesmo em todas as direções. A esse tipo de meio dá-se o nome de isotrópico. Em fluidos heterogêneos o coeficiente pode variar dependendo da direção. Esses são os meios anisotrópicos. Um exemplo de meio anisotrópico são os tecidos biológicos.

\begin{figure}[h!]
\vspace{-20pt}
\begin{center}
\subfigure[Difusão em diferentes direções]{\includegraphics[width=0.45\textwidth]{anisotropia}}
\qquad
\subfigure[Moléculas de água tendem a se difundir com maior facilidade nas direções que não apresentam barreiras (membranas)]{\includegraphics[width=0.45\textwidth]{neuronio}}
\end{center}
\vspace{-20pt}
\caption{O conceito de isotropia e anisotropia}
\vspace{-10pt}
\end{figure}

Imagens de ressonância magnética de difusão são uma das formas de obter informações sobre o coeficiente de difusão de moléculas de água em diferentes direções nesses tipos de tecidos.

Para representar tais coeficientes são utilizados tensores, que são abstrações de escalares, vetores e matrizes utilizados em diversas aplicações. Em imagens de ressonância magnética de difusão, tais tensores são comumente representados por matrizes $ 3 \times 3 $ simétricas.

\subsection{Representação elipsoidal de tensores de difusão}
Em meios isotrópicos o coeficiente de difusão pode ser representado por uma esfera, pois o movimento das moléculas se distribui igualmente para todas as direções em um determinado período de tempo. Já em meios anisotrópicos, como o movimento depende da direção, o coeficiente é modelado como um elipsóide, sendo que os semi-eixos têm comprimento proporcional aos autovalores do tensor ($\lambda_{1} > \lambda_{2} > \lambda_{3}$) ao longo dos seus autovetores $\epsilon_{1}, \epsilon_{2}, \epsilon_{3}$.

\subsection{Anisotropia Fracionada}
A anisotropia fracionada é um valor no intervalo $ [0,1] $ que descreve o grau de anisotropia de um processo de difusão. Sejam $\lambda_{1}, \lambda_{2}, \lambda_{3}$ os autovalores do tensor. A anisotropia fracionada ($AF$) pode ser calculada a partir da seguinte fórmula\cite{hagmann}:

\begin{equation}
AF = \sqrt{\frac{1}{2}}\frac{\sqrt{(\lambda_{1}-\lambda_{2})^{2} + (\lambda_{1}-\lambda_{3})^{2} + (\lambda_{2}-\lambda_{3})^{2}}}{\sqrt{\lambda_{1}^{2} + \lambda_{2}^{2} + \lambda_{3}^{2}}}
\label{af}
\end{equation}

A anisotropia fracionada pode também ser dividida em três medidas (linear, planar e esférica) que indicam a forma da difusão\cite{westinISMRM97}. Sejam $\lambda_{1} \geq \lambda_{2} \geq \lambda_{3} \geq 0$:

Caso linear:
\begin{equation}
C_{l} = \frac{\lambda_{1} - \lambda_{2}}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{linearCase}
\end{equation}

Caso planar:
\begin{equation}
C_{p} = \frac{2(\lambda_{2} - \lambda_{3})}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{planarCase}
\end{equation}

Caso esférico:
\begin{equation}
C_{s} = \frac{3\lambda_{3}}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{sphericalCase}
\end{equation}

Tais medidas também pertencem ao intervalo $ [0,1] $. Quanto mais próximo de 1, em cada caso, mais o tensor se assemelha à forma referente.
