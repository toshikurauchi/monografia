\section{Tecnologias estudadas}

Nessa seção serão apresentadas as tecnologias que foram estudadas para o desenvolvimento da engine gráfica Pandora's Box.

\subsection{Linguagem C++98}
A linguagem de programação C++ é uma linguagem multiparadigma, que suporta tanto
programação estruturada quanto orientada a objetos. Ela foi desenvolvida como
uma evolução da linguagem C e, por esse motivo, suas sintaxes são semelhantes.

\vsection{Variáveis e funções}

As variáveis e funções são declaradas com a mesma sintaxe utilizada na linguagem C (um tipo seguido de um nome, podendo receber um valor inicial):

\begin{codigo}
<tipo> <nome> [= <valor inicial>]
\end{codigo}

Ou seja, para declarar uma variável inteira chamada \texttt{contador} com valor inicial zero é utilizada a seguinte sintaxe:

\begin{codigo}
int contador = 0;
\end{codigo}

\vsection{Classes e objetos}

Classes são definidas pelas palavras reservadas \texttt{class} ou \texttt{struct}, 
sendo que a diferença entre elas é o fato de atributos de uma \texttt{class} serem 
privados por padrão e os de uma \texttt{struct}, públicos. É possível adicionar 
modificadores de acesso através das palavras \texttt{public}, \texttt{private} e 
\texttt{protected} que definem acesso livre em todos os escopos, acesso restrito 
à classe e acesso restrito à classe e suas subclasses respectivamente. Construtores 
são declarados como funções com o nome da classe sem valor e tipo de retorno. A 
declaração de uma classe \texttt{Coordenada2d} poderia ocorrer das seguintes maneiras:

Utilizando \texttt{class}:

\begin{codigo}
class Coordenada2d {
public:
    Coordenada2d(double x, double y);
private:
    double x,y;
};

\end{codigo}

Utilizando \texttt{struct}:

\begin{codigo}
struct Coordenada2d {
    double x,y;
};
\end{codigo}

Para se instanciar um objeto existem duas opções. A primeira consiste em declarar uma 
variável cujo tipo é o nome da classe desejada (da mesma forma como variáveis do
tipo \texttt{int} são declaradas, por exemplo). Na declaração da variável a classe será instanciada e inicializada. 
A segunda maneira é a utilização da palavra reservada \texttt{new} seguida do
nome da classe. O valor devolvido é um ponteiro para uma instância da classe
desejada. Seguindo o exemplo anterior, a classe Coordenada2d poderia ser instanciada das seguintes formas:

\begin{codigo}
Coordenada2d coordenada1;
Coordenada2d * coordenada2 = new Coordenada2d;
\end{codigo}

Os argumentos do construtor são passados da seguinte maneira:

\begin{codigo}
Coordenada2d coordenada1(1.0, 2.0);
Coordenada2d * coordenada2 = new Coordenada2d(1.0, 2.0);
\end{codigo}

\vsection{Namespaces}

Para evitar colisão de identificadores como nomes de classes, variáveis e funções é possível utilizar um \texttt{namespace}:

\begin{codigo}
namespace nome {
// Entidades
    int n;
}
\end{codigo}

Onde \texttt{nome} é qualquer identificador válido e \texttt{Entidades} é o conjunto de classes, variáveis e funções que ficarão protegidas dentro de um \texttt{namespace}.

Para referenciar identificadores de um \texttt{namespace} é utilizada a seguinte sintaxe:

\begin{codigo}
<nome do namespace>::<identificador>
\end{codigo}

Para acessar a variável \texttt{n} do exemplo utiliza-se o seguinte código:

\begin{codigo}
nome::n
\end{codigo}

\vsection{Templates}

O template é um recurso da linguagem C++ que permite programação genérica. É utilizado 
para a implementação de funções ou classes cujas funcionalidades podem ser adaptadas para 
tipos diferentes com o mesmo código. Para isso é utilizada a palavra reservada \texttt{template} 
seguida por um parâmetro de template, que é um tipo especial de parâmetro que pode ser utilizado 
para enviar tipos como argumento.

Uma função \texttt{maximo} poderia ser definida da seguinte maneira:

\begin{codigo}
template <class T>
T maximo(T a, T b) {
    T resultado;
    resultado = (a > b) ? a : b;
    return resultado;
}
\end{codigo}

O código acima pode ser utilizado da seguinte maneira:

\begin{codigo}
int c = 4, d = 5;
maximo(c,d);
\end{codigo}

Um nó de uma lista ligada genérica poderia ser implementado de maneira análoga:

\begin{codigo}
template <class T>
class No {
public:
    No(T valorInicial) {
        valor = valorInicial;
        proximo = NULL;
    }
    T getValor() {
        return valor;
    }
    void setValor(T novoValor) {
        valor = novoValor;
    }
    No<T> * getProximo() {
        return proximo;
    }
    void setProximo(No<T> *novoProximo) {
        proximo = novoProximo;
    }
private:
    T valor;
    No<T> *proximo;
};
\end{codigo}

A utilização também é análoga à de funções, porém como o compilador
não consegue deduzir o tipo de T, deve-se declará-lo explicitamente:

\begin{codigo}
No<int> meuNo(5);
\end{codigo}

\subsubsection{A Standard Template Library (STL)}

A Standard Template Library (STL)~\cite{stl}é a biblioteca padrão do C++ que
oferece um conjunto grande de algoritmos e estruturas de dados genéricos.

É possível, por exemplo, aplicar uma função para todos os itens de um vetor de inteiros da seguinte maneira:

\begin{codigo}
void imprime(int i) {
    printf("%d ", i);
}
int main() {
    std::vector<int> vetor;
    // Adicionando os valores 1, 2 e 3 no vetor
    vetor.push_back(1);
    vetor.push_back(2);
    vetor.push_back(3);
    
    for_each(vetor.begin(), vetor.end(), imprime);
    // Saída: 1 2 3
    return 0;
}
\end{codigo}

O método \texttt{for\_each} pode, alternativamente, receber no lugar da
função, uma instância de uma classe que implementa o método
\texttt{operator()}:

\begin{codigo}
struct impressor {
    void operator() (int i) {
        printf("%d ", i);
    }
} meuImpressor;

int main() {
    std::vector<int> vetor;
    vetor.push_back(1);
    vetor.push_back(2);
    vetor.push_back(3);

    for_each(vetor.begin(), vetor.end(), meuImpressor);
    // Saída: 1 2 3
    return 0;
}
\end{codigo}

Há diversos outros tipos de algoritmos implementados na STL~\cite{algorithm}.

\subsection{Boost C++ Libraries}

Boost~\cite{boost} é uma biblioteca de C++ de código aberto inicialmente desenvolvida 
como uma extensão para a STL sob o namespace \texttt{boost}. Os principais módulos dessa 
biblioteca utilizados no desenvolvimento da engine foram \texttt{bind}, \texttt{function} 
e \texttt{smart\_ptr}. 

O módulo \texttt{function} cria functors (instâncias de classes que implementam
 o método \texttt{operator()}) que são capazes de armazenar tanto funções nativas
 da linguagem quanto outros functors. Essas funções são criadas através da seguinte construção:

\begin{codigo}
void f (int i, int j, int k) {
    // implementação
}

// A boost::function recebe o número n de argumentos, o tipo do valor
// de retorno e os tipos dos n argumentos
// boost::function[n]<tipo de retorno, tipos dos argumentos>
boost::function3<void,int,int,int> funcao = f;
\end{codigo}

A biblioteca \texttt{bind} cria functors a partir de uma função ou outro functor
mas com alguns argumentos já definidos, por exemplo:

\begin{codigo}
boost::bind(f, 1, _1, _2)
\end{codigo}

Nesse caso \texttt{boost::bind} cria um functor que recebe apenas dois
argumentos, indicados pelos nomes \texttt{\_1} e \texttt{\_2}, o primeiro e o
segundo argumento do functor criado respectivamente.

As funcionalidades de \texttt{bind} e \texttt{function} podem ser combinadas:

\begin{codigo}
// functor sem retorno que recebe dois argumentos inteiros
boost::function2<void, int, int> functor1 = 
				boost::bind(f, 1, _1, _2);
				
// cria um boost::function a partir do resultado do boost::bind
// de uma boost::function
boost::function1<void, int> functor2 = boost::bind(functor1, 2, _1);
\end{codigo}

Os módulos \texttt{bind} e \texttt{function} da boost são utilizados
principalmente em conjunto com algoritmos da STL, como o
\texttt{std::for\_each}:

\begin{codigo}
void imprime(int i) {
    printf("%d ", i);
}

int main() {
    std::vector<int> vetor;
    boost::function1<void, int> impressor = imprime;
    
    // Adicionando os valores 1, 2 e 3 no vetor
    vetor.push_back(1);
    vetor.push_back(2);
    vetor.push_back(3);

    for_each(vetor.begin(), vetor.end(), impressor);
    // Saída: 1 2 3

    return 0;
}
\end{codigo}

Os \texttt{smart\_ptr} são classes que guardam ponteiros para áreas de memória alocadas dinamicamente. 
Essas classes tem comportamento semelhante ao de ponteiros nativos da linguagem, com a diferença de que 
elas desalocam o recurso a que referenciam em momento adequado. Existem seis tipos \texttt{smart\_ptr} definidos:

\begin{itemize}
\item \texttt{scoped\_ptr}: representa o conceito de ponteiro não compartilhável, logo não pode ser copiado. Desaloca a memória ao sair de escopo.
\item \texttt{scoped\_array}: mesmo que \texttt{scoped\_ptr} mas para um array de objetos.
\item \texttt{shared\_ptr}: representa um ponteiro com diversos donos, pode ser
copiado e só é destruído quando todos os donos forem destruídos.
\item \texttt{shared\_array}: mesmo que \texttt{shared\_ptr} mas para arrays.
\item \texttt{weak\_ptr}: são ponteiros para recursos de um \texttt{shared\_ptr} mas que não são donos do recurso.
\item \texttt{intrusive\_ptr}: são \texttt{shared\_ptr} que guardam dentro do objeto para o qual apontam o contador de referências utilizado internamente.
\end{itemize}

\subsection{OpenGL}

O OpenGL é uma especificação aberta, extensível~\cite{openglregistry},
amplamente adotada no mercado e independente do sistema operacional de uma
interface de software para o hardware gráfico.

Para se manter minimalista, o OpenGL não especifica nada
que dependa do sistema operacional, como gerenciamento de janelas ou controle de
entrada e saída de dados, assim como também não suporta nenhum tipo de formato
de arquivo como imagens (png, jpg, bmp) e modelos (3ds~\cite{3dsfileformat},
blend~\cite{blendfileformat}, ou obj~\cite{objfileformat}), ele apenas oferece
formas de se combinar diferentes vértices para se formar primitivas e de fazer
com que essas primitivas sejam transformadas em pixels.

\begin{wrapfigure}{r}{0.3\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.3\textwidth]{pipeline}
\end{center}
\vspace{-20pt}
\captionsetup{margin=15pt}
\caption{Na GPU as primitivas do OpenGL passam pelos 5 estágios do pipeline
representados acima.}
\vspace{-45pt}
\end{wrapfigure}

As primitivas criadas na CPU (Central Processing Unit) são enviadas para a GPU
(Graphics Processing Unit) onde serão processadas e utilizadas para gerar os pixels de uma
imagem que será mostrada na janela. Esse processo é conhecido como pipeline e é dividido em 5 estágios
principais compostos por shaders (programas executados pela GPU):

\begin{itemize}
  \item \textbf{Vertex shader}: cada vértice é transformado para a sua
  coordenada final.
  \item \textbf{Tesselation shaders}: as primitivas formadas após a execução do
  vertex shader podem ser opcionalmente quebradas em primitivas menores.
  \item \textbf{Geometry shader}: a partir das primitivas geradas nos passos
  anteriores, o geometry shader decide se novas primitivas devem ser geradas.
  \item \textbf{Rasterização}: nessa etapa as primitivas de 3 dimensões são
  projetadas em um plano, que representa a janela do usuário. Essa projeção gera fragmentos,
  que são candidatos a pixels.
  \item \textbf{Fragment shader}: cada fragmento gerado na
  rasterização é processado pelo fragment shader e, após a execução, passa por
  um teste de profundidade, que determina se o fragmento é visível. Caso
  passe no teste, ele é escrito no framebuffer e se torna um pixel visível,
  senão, é descartado.
\end{itemize}

No OpenGL todos esses processos (com exceção da rasterização) são customizáveis, 
entretanto na Pandora's Box somente o vertex shader e o fragment shader podem ser 
modificados. Mais detalhes são apresentados na seção~\ref{atividades}.
\newpage
\vsection{O contexto do OpenGL}

O OpenGL é implementado internamente como uma máquina de estados. 
Tais estados, assim como outras informações, como a janela e texturas são
 guardados em um contexto, que deve ser criado e inicializado para o 
 funcionamento da aplicação. Essa criação é dependente da plataforma e por 
 esse motivo não está definida na API do OpenGL.

\subsection{GLEW}

OpenGL Extension Wrangler Library~\cite{glew}, conhecida como
GLEW é uma biblioteca que auxilia no gerenciamento de extensões do OpenGL. 
Ela define constantes em tempo de execução contendo as extensões suportadas pelo 
sistema do usuário e, além disso, obtém os ponteiros das novas funções definidas
nas extensões.

O uso da GLEW é ilustrado no código abaixo:

\begin{codigo}
#include <GL/glew.h>
// Após a inicialização do contexto do OpenGL
glewInit();
// após a inicialização as funções definidas através de extensões
// estão disponíveis

// verificar se a extensão GL_ARB_vertex_program está disponível
if(GLEW_ARB_vertex_program) {
    ...
}
// ou
if(glewIsSupported("GL_ARB_vertex_program")) {

}
\end{codigo}

\subsection{Windows API}

Como citado anteriormente, o OpenGL não é responsável por criar janelas e tratar eventos 
gerados pelo sistema operacional, esse tratamento é dependente do ambiente no qual o 
programa será executado. Nesse trabalho foi utilizada apenas a API do sistema
operacional Windows que está contida no \texttt{windows.h}.

Um texto detalhado sobre a criação de janelas pode ser encontrado
no apêndice~\ref{criacaojanela} e a documentação da Windows API
encontra-se no site da MSDN~\cite{msdn}
\newpage
\vsection{Carregamento dinâmico de DLL}

Para que seja possível suportar diversas implementações independentes de especificações 
de APIs gráficas, a engine possui um mecanismo de carregamento dinâmico de DLLs
(os detalhes sobre o carregamento de DLLs podem ser encontrados no
apêndice~\ref{dllload}).


\section{Conceitos estudados}

A seguir serão apresentados os conceitos que foram estudados para a implementação da engine, assim como na aplicação de exemplo (visualização de campos tensoriais)

\subsection{Transformações lineares}
O conceito de transformações lineares é de importância fundamental para a 
computação gráfica, pois podem ser aplicadas sobre geometrias sem alterar a
sua forma (realizando movimentos de translação ou rotação por exemplo). Podem
ser representadas como matrizes bastando multiplicá-las para realizar
composições.

Em computação gráfica, é comum a utilização de coordenadas homogêneas para
a representação de vértices~\cite{redbook} e de matrizes de transformação
$4\times4$.
As transformações mais aplicadas sobre modelos geométricos e suas
respectivas matrizes são:

\begin{itemize}
  \item Translação:
  \begin{displaymath}
    \left(
    \begin{array}{cccc}
    1 & 0 & 0 & t_x \\
    0 & 1 & 0 & t_y \\
    0 & 0 & 1 & t_z \\
    0 & 0 & 0 & 1 
    \end{array}
    \right)
  \end{displaymath}
  Onde $t_x, t_y, t_z$ são as translações nos eixos $x, y, z$ respectivamente.
  
  \item Rotação de $\theta$ em torno do eixo x:
    \begin{displaymath}
    \left(
    \begin{array}{cccc}
    1 & 0 & 0 & 0 \\
    0 & cos\theta & -sen\theta & 0 \\
    0 & sen\theta & cos\theta & 0 \\
    0 & 0 & 0 & 1 
    \end{array}
    \right)
    \end{displaymath}
  \item Rotação de $\theta$ em torno do eixo y:
    \begin{displaymath}
    \left(
    \begin{array}{cccc}
    cos\theta & 0 & sen\theta & 0 \\
    0 & 1 & 0 & 0 \\
    -sen\theta & 0 & cos\theta & 0 \\
    0 & 0 & 0 & 1 
    \end{array}
    \right)
    \end{displaymath}
  \item Rotação de $\theta$ em torno do eixo z:
    \begin{displaymath}
    \left(
    \begin{array}{cccc}
    cos\theta & -sen\theta & 0 & 0 \\
    sen\theta & cos\theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 
    \end{array}
    \right)
    \end{displaymath}
  \item Escala:
    \begin{displaymath}
    \left(
    \begin{array}{cccc}
    s_x & 0 & 0 & 0 \\
    0 & s_y & 0 & 0 \\
    0 & 0 & s_z & 0 \\
    0 & 0 & 0 & 1 
    \end{array}
    \right)
    \end{displaymath}
    
    Onde $s_x, s_y, s_z$ são as escalas aplicadas nos eixos $x, y, z$ respectivamente.
\end{itemize}

\subsection{Tensores de imagens de ressonância magnética de difusão}

Difusão é o nome dado ao movimento aleatório de moléculas em um fluido (líquido
ou gasoso) e denomina-se coeficiente de difusão a facilidade com que uma
molécula se desloca em determinado meio. Em fluidos homogêneos, como a água, o
coeficiente de difusão é o mesmo em todas as direções.
A esse tipo de meio dá-se o nome de isotrópico. Em fluidos heterogêneos o coeficiente pode variar 
dependendo da direção. Esses são os meios anisotrópicos. Um exemplo de meio anisotrópico são os 
tecidos biológicos.

\begin{figure}[h!]
\vspace{-20pt}
\begin{center}
\subfigure[Difusão em diferentes direções]{\includegraphics[width=0.45\textwidth]{anisotropia}}
\qquad
\subfigure[Moléculas de água tendem a se difundir com maior facilidade nas direções que não apresentam barreiras (membranas)]{\includegraphics[width=0.45\textwidth]{neuronio}}
\end{center}
\vspace{-20pt}
\caption{O conceito de isotropia e anisotropia aplicado a tecidos biológicos.}
\vspace{-10pt}
\end{figure}

Imagens de ressonância magnética de difusão são uma das formas de se obter 
informações sobre o coeficiente de difusão de moléculas de água em diferentes 
direções em tecido biológicos.

Para representar tais coeficientes são utilizados tensores, que são abstrações
de escalares, vetores e matrizes com diversas aplicações na ciência e
matemática. Em imagens de ressonância magnética de difusão, tais tensores são
comumente representados por matrizes $ 3 \times 3 $ simétricas.

\subsection{Representação elipsoidal de tensores de difusão}
Em meios isotrópicos o coeficiente de difusão pode ser representado por uma
esfera, pois o movimento das moléculas se distribui igualmente para todas as 
direções em um determinado período de tempo. Já em meios anisotrópicos, como 
o movimento depende da direção, o coeficiente é modelado como um elipsóide, 
sendo que os semi-eixos têm comprimento proporcional aos autovalores do tensor 
($\lambda_{1} > \lambda_{2} > \lambda_{3}$) ao longo dos seus autovetores 
$\epsilon_{1}, \epsilon_{2}, \epsilon_{3}$.

\subsection{Anisotropia Fracionada}
A anisotropia fracionada é um valor no intervalo $ [0,1] $ que descreve o grau
de anisotropia de um processo de difusão. Sejam $\lambda_{1}, \lambda_{2}, \lambda_{3}$ 
os autovalores do tensor. A anisotropia fracionada ($AF$) pode ser calculada a partir 
da seguinte fórmula~\cite{hagmann}:

\begin{equation}
AF = \sqrt{\frac{1}{2}}\frac{\sqrt{(\lambda_{1}-\lambda_{2})^{2} + (\lambda_{1}-\lambda_{3})^{2} + (\lambda_{2}-\lambda_{3})^{2}}}{\sqrt{\lambda_{1}^{2} + \lambda_{2}^{2} + \lambda_{3}^{2}}}
\label{af}
\end{equation}

A anisotropia fracionada pode também ser dividida em três medidas (linear,
planar e esférica) que indicam a forma da difusão~\cite{westinISMRM97}. 
Sejam $\lambda_{1} \geq \lambda_{2} \geq \lambda_{3} \geq 0$:

Caso linear:
\begin{equation}
C_{l} = \frac{\lambda_{1} - \lambda_{2}}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{linearCase}
\end{equation}

Caso planar:
\begin{equation}
C_{p} = \frac{2(\lambda_{2} - \lambda_{3})}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{planarCase}
\end{equation}

Caso esférico:
\begin{equation}
C_{s} = \frac{3\lambda_{3}}{\lambda_{1} + \lambda_{2} + \lambda_{3}}
\label{sphericalCase}
\end{equation}

Tais medidas também pertencem ao intervalo $ [0,1] $. Quanto mais próximo de 1, em cada caso, 
mais o tensor se assemelha à forma referente.
