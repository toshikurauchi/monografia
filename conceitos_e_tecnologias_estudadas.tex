\section{Conceitos e tecnologias estudadas}
Conceitos utilizados na implementação da engine, assim como tensores e suas formas de visualização. Além de uma breve introdução ao OpenGL e C++.

\subsection{Linguagem C++98}
A linguagem de programação C++ foi desenvolvida como uma evolução da linguagem C. %É uma linguagem estruturada e orientada a objetos

\subsubsection{Variáveis e funções}
As variáveis e funções são declaradas com a mesma sintaxe utilizada na linguagem C (um qualificador seguido de um tipo e de um nome, podendo receber um valor inicial):

% Pensar em uma forma melhor de mostrar isso.
\begin{verbatim}
<qualificador> <tipo> <nome>[=<valor inicial>]
\end{verbatim}

\subsubsection{Classes e objetos}
Classes são definidas pelas palavras reservadas \texttt{class} ou \texttt{struct}, sendo que a diferença entre elas é o fato de atributos de uma \texttt{class} serem privados por padrão e os de uma \texttt{struct}, públicos. É possível adicionar modificadores de acesso através das palavras \texttt{public}, \texttt{private} e \texttt{protected} que definem acesso livre em todos os escopos, acesso restrito à classe e acesso restrito à classe e suas subclasses respectivamente. Construtores são declarados como funções com o nome da classe. A declaração de uma classe \texttt{Coordenada2d} poderia ocorrer das seguintes maneiras:

Utilizando \texttt{class}:

\begin{verbatim}
class Coordenada2d {
public:
    Coordenada2d(double x, double y);
private:
    double x,y;
};
\end{verbatim}

Utilizando \texttt{struct}:

\begin{verbatim}
struct Coordenada2d {
    double x,y;
};
\end{verbatim}

Para se instanciar um objeto existem duas opções. A primeira consiste em declarar uma variável da classe desejada (da mesma forma como variáveis do tipo \texttt{int} são declaradas, por exemplo). Na declaração da variável a classe será instanciada e inicializada. A segunda maneira é a utilização da palavra reservada \texttt{new} seguida do nome da classe. O valor devolvido é um ponteiro para uma instância da classe desejada. Seguindo o exemplo anterior, a classe Coordenada2d poderia ser instanciada das seguintes formas:

\begin{verbatim}
Coordenada2d coordenada1;
Coordenada2d * coordenada2 = new Coordenada2d;
\end{verbatim}

Os argumentos do construtor são passados da seguinte maneira:

\begin{verbatim}
Coordenada2d coordenada1(1.0, 2.0);
Coordenada2d * coordenada2 = new Coordenada2d(1.0, 2.0);
\end{verbatim}

\subsubsection{Namespaces}
Para evitar colisão de identificadores como nomes de classes, variáveis e funções é possível utilizar um \texttt{namespace}:

\begin{verbatim}
namespace nome {
// Entidades
    int n;
}
\end{verbatim}

Onde \texttt{nome} é qualquer identificador válido e \texttt{Entidades} é o conjunto de classes, variáveis e funções que ficarão protegidas dentro de um \texttt{namespace}.

Para referenciar identificadores de um \texttt{namespace} é utilizada a seguinte sintaxe:

\begin{verbatim}
<nome do namespace>::<identificador>
\end{verbatim}

Para acessar a variável \texttt{n} do exemplo utiliza-se o seguinte código:

\begin{verbatim}
nome::n
\end{verbatim}

\subsubsection{Templates}
Possibilitam programação genérica

\subsubsection{A Standard Template Library (STL)}

A Standard Template Library (STL)~\cite{stl}é uma biblioteca C++ baseada em templates que oferece um conjunto de algoritmos e estruturas de dados configuráveis.

\subsection{Boost C++ Libraries}

Boost~\cite{boost} é uma biblioteca de C++ de código aberto inicialmente desenvolvida como uma extensão para a STL dentro do \texttt{boost}. Os principais módulos da boost utilizados no desenvolvimento da engine foram \texttt{bind}, \texttt{function} e \texttt{smart\_ptr}. 

O módulo \texttt{function} cria functors que são capazes de armazenar tanto funções nativas da linguagem ou quanto outros functors. Essas funções são criadas através da seguinte construção:

\begin{verbatim}
void f (int i, int j, int k) {
    // implementação
}
// boost::function[numero de argumentos]<tipo de retorno, tipos dos argumentos>
boost::function3<void,int,int,int> funcao = f;
\end{verbatim}

A biblioteca \texttt{bind} cria functors (classes que implementam o método operator ()) a partir de uma função ou outro functor mas com alguns argumentos já posicionados, por exemplo:

\begin{verbatim}
boost::bind(f, 1, _1, _2)
\end{verbatim}

Nesse caso boost::bind cria um functor que recebe apenas dois argumentos, indicados pelos nomes \_1 e \_2, o primeiro e o segundo argumento do functor criado respectivamente.

As funcionalidades de bind e function podem ser combinadas:

\begin{verbatim}
// functor sem retorno que recebe dois argumentos inteiros
boost::function2<void, int, int> functor1 = boost::bind(f, 1, _1, _2);
// cria um boost::function a partir do resultado do boost::bind de uma 
// boost::function
boost::function1<void, int> functor2 = boost::bind(functor1, 2, _1);
\end{verbatim}

Os módulos bind e function da boost são utilizados principalmente em conjunto com algoritmos da STL, como o std::for\_each.

Os \texttt{smart\_ptr} são classes que guardam ponteiros para áreas de memória alocadas dinamicamente. Essas classes tem comportamento parecido com o de ponteiros nativos da linguagem, com a diferença de que elas desalocam o recurso a que referenciam em momento adequado. Existem seis tipos smart\_ptr definidos:

\begin{itemize}
\item scoped\_ptr: representa o conceito de ponteiro não compartilhável, logo não podem ser copiados. Desalocam a memória ao sair de escopo.
\item scoped\_array: mesmo que scoped\_ptr mas para um array de objetos.
\item shared\_ptr: representa um ponteiro que tem diversos donos, pode ser copiado e só é destruído quando todos os donos forem destruídos.
\item shared\_array: mesmo que shared\_ptr mas para arrays.
\item weak\_ptr: são ponteiros para recursos de um shared\_ptr mas que não são donos do recurso.
\item intrusive\_ptr: são shared\_ptr que guardam dentro do objeto para o qual apontam o contador de referências utilizado internamente.
\end{itemize}

\subsection{OpenGL}

\subsection{Windows API}
%Citar anteriormente...
Como citado anteriormente, o OpenGL não é responsável por criar janelas e tratar eventos gerados pelo sistema operacional, esse tratamento é dependente do ambiente no qual o programa será executado. Nesse trabalho utilizamos apenas a API do sistema operacional Windows.

Para se inicializar um contexto para a execução de programas de OpenGL, é necessário criar uma janela, para isso usa-se a seguinte função\cite{doccreatewindow}:

\begin{verbatim}
HWND WINAPI CreateWindow(
  __in_opt  LPCTSTR lpClassName,
  __in_opt  LPCTSTR lpWindowName,
  __in      DWORD dwStyle,
  __in      int x,
  __in      int y,
  __in      int nWidth,
  __in      int nHeight,
  __in_opt  HWND hWndParent,
  __in_opt  HMENU hMenu,
  __in_opt  HINSTANCE hInstance,
  __in_opt  LPVOID lpParam
);
\end{verbatim}

Onde:
\begin{itemize}
\item lpClassName: representa uma classe registrada anteriormente no sistema.
\item lpWindowName: representa o título da janela.
\item dwStyle: conjunto de flags que definem como a janela será exibida\cite{docwindowstyle}: com bordas, maximixada, minimizada, \ldots
\item x, y: posição inicial da janela.
\item nWidth, nHeight: dimensões iniciais da janela.
\item hWndParent: se a janela que está sendo criada é uma subjanela de uma já existente, passa-se o handler da janela pai nesse argumento, caso contrário, passa-se NULL. Para a engine gráfica, esse argumento sempre recebe o valor NULL.
\item hMenu: se for necessário criar uma menu, deve-se passar o handler do menu nesse argumento, caso contrário, passa-se NULL.
\item hInstance: o handler da instância do programa que está sendo executado, esse parâmetro é utilizado dentro do sistema na criação de um identificador único para a janela.
\item lpParam: dados do usuário. Esse parâmetro recebe um ponteiro para qualquer tipo de dado que o usuário necessite. Na engine esse argumento recebe o ponteiro para uma instância de uma classe interna que representa a janela do sistema.
\end{itemize}

Para se registrar uma classe no sistema deve-se chamar a função\cite{docregisterclass}:
\begin{verbatim}
ATOM WINAPI RegisterClass(
  __in  const WNDCLASS *lpWndClass
);
\end{verbatim}

O argumento lpWndClass um ponteiro para uma instância de \texttt{WNDCLASS}\cite{docwndclass}, uma estrutura que guarda, entre outras coisas, o nome da classe que está sendo registrada, o ponteiro para a função que irá tratar os eventos gerados pelo sistema e uma flag que indica se o contexto do dispositivo\cite{docdevicecontext} pode ser compartilhado. Quando se cria um contexto do OpenGL é importante sempre registrar a classe como dona do contexto do dispositivo.

Após criada, deve-se avisar o sistema que a janela é visível, para isso, executa-se\cite{docshowwindow}:

\begin{verbatim}
BOOL WINAPI ShowWindow(
  __in  HWND hWnd,
  __in  int nCmdShow
);
\end{verbatim}

Onde hWnd é o handler retornado pela função \texttt{CreateWindow} e nCmdShow controla como a janela deve ser exibida (maximizada, minimizada, simplesmente exibida, \ldots)

Depois de criar a janela, a thread mãe começa a receber os eventos da janela criada em sua fila de mensagens. Para se recuperar uma mensagem da fila, utiliza-se a função\cite{docgetmessage}:

\begin{verbatim}
BOOL WINAPI GetMessage(
  __out     LPMSG lpMsg,
  __in_opt  HWND hWnd,
  __in      UINT wMsgFilterMin,
  __in      UINT wMsgFilterMax
);
\end{verbatim}

Que recebe como parâmetros um ponteiro para uma estrutura do tipo \texttt{MSG}\cite{docmsg}, o handler retornado pela função \texttt{CreateWindow} e 

\subsubsection{O loop de eventos da janela}

A função registrada na WNDCLASS que tratará os eventos gerados pelo sistema deve ter a seguinte assinatura\cite{docwindowproc}:
\begin{verbatim}
LRESULT CALLBACK WindowProc(
  __in  HWND hwnd,
  __in  UINT uMsg,
  __in  WPARAM wParam,
  __in  LPARAM lParam
);
\end{verbatim}

\subsection{Transformações lineares}

\subsection{Tensores de imagens de ressonância magnética de difusão}
Difusão é o nome dado ao movimento aleatório de moléculas em um fluido (líquido ou gasoso). Denomina-se coeficiente de difusão a facilidade com que uma molécula se move no meio. Em fluidos homogêneos, como a água, o coeficiente de difusão é o mesmo em todas as direções. A esse tipo de meio dá-se o nome de isotrópico. Em fluidos heterogêneos o coeficiente pode variar dependendo da direção. Esses são os meios anisotrópicos. Um exemplo de meio anisotrópico são os tecidos biológicos.

Imagens de ressonância magnética de difusão são um dos meios de obter informações sobre o coeficiente de difusão de moléculas de água em diferentes direções em tecidos biológicos.

Para representar tais coeficientes são utilizados tensores, que são abstrações de escalares, vetores e matrizes utilizados em diversas aplicações. Em imagens de ressonância magnética de difusão, tais tensores são representados por matrizes $ 3 \times 3 $ simétricas.

% Pensar melhor nesse nome
\subsection{Representação gráfica de tensores}
Em meios isotrópicos o coeficiente de difusão pode ser representado por uma esfera, pois o movimento das moléculas se distribui igualmente para todas as direções em um determinado período de tempo. Já em meios anisotrópicos, como o movimento depende da direção, o coeficiente é modelado como um elipsóide, sendo que os semi-eixos têm comprimento proporcional aos autovalores do tensor ($\lambda_{1} > \lambda_{2} > \lambda_{3}$) ao longo dos seus autovetores $\epsilon_{1}, \epsilon_{2}, \epsilon_{3}$.
