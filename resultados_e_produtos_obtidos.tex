\section{Resultados e produtos obtidos}

O código do Pandora's Box Graphics Engine, assim como da aplicação de visualização de campos tensoriais e outros exemplos pode ser encontrado no seguinte endereço:

\url{https://github.com/victorkendy/PandoraBox}

\subsection{Compilador de campos tensoriais}
A aplicação de compilação de campos tensoriais pode ser executada através da linha de comando com os seguintes argumentos opcionais:

\begin{verbatim}
field_compiler.exe [ARQUIVO DO CAMPO] [ARQUIVO CTF]
\end{verbatim}

Caso o programa seja executado sem nenhum argumento o usuário deve escolher entre as opções 1 e 2 (campo de uma dupla hélice sintética e de um cérebro humano respectivamente). A opção \texttt{ARQUIVO DO CAMPO} deve indicar o nome de um arquivo .img sem a extensão (supõe-se que o arquivo .hdr tenha o mesmo nome), ou seja, suponha que existam os arquivos \texttt{campo.hdr} e \texttt{campo.img}, então o argumento deve ser \texttt{campo}. O último argumento deve ser o nome do arquivo .ctf a ser criado, por exemplo \texttt{campo.ctf}.

\subsection{Visualizador de campos tensoriais}
O visualizador de campos tensoriais também pode ser executada através da linha de comando da seguinte maneira:

\begin{verbatim}
tensor_field.exe [ARQUIVO CTF]
\end{verbatim}

A execução sem nenhum argumento permitirá ao usuário escolher entre os dois campos utilizados como teste (dupla hélice e cérebro). É possível visualizar outros campos no formato .ctf enviando como argumento o nome do arquivo, por exemplo \texttt{campo.ctf}.

\subsubsection{Movimentação e interação com o campo tensorial}
É possível utilizar as seguintes teclas para interagir com o campo tensorial:

\begin{center}
	\begin{longtable}{ | c | p{10cm} | }
	\hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Alternância de efeitos}} \\ \hline
	1 & Ativa/desativa o inversor de cores \\ \hline
	2 & Ativa/desativa o filtro do componente vermelho das cores \\ \hline
	3 & Ativa/desativa o efeito de lentes senoidais \\ \hline
	4 & Ativa/desativa o depth peeling \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Movimentação da câmera}} \\ \hline
	W & Move a câmera para cima \\ \hline
	S & Move a câmera para baixo \\ \hline
	A & Move a câmera para a esquerda \\ \hline
	D & Move a câmera para a direita \\ \hline
	Q & Move a câmera em direção ao campo \\ \hline
	E & Move a câmera na direção oposta ao campo \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Nível de anisotropia considerado (são somente mostrados os elipsóides que representam tensores cuja anisotropia fracionada pertence ao intervalo [min\_AF,max\_AF])}} \\ \hline
	Z & Aumenta o valor de min\_AF \\ \hline
	X & Diminui o valor de min\_AF \\ \hline
	V & Aumenta o valor de max\_AF \\ \hline
	C & Diminui o valor de max\_AF \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Escala dos elipsóides}} \\ \hline
	O & Diminui o tamanho dos elipsóides \\ \hline
	P & Aumenta o tamanho dos elipsóides \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Cálculo da anisotropia fracionada}} \\ \hline
	R & Utiliza o cálculo da forma linear \\ \hline
	T & Utiliza o cálculo da forma planar \\ \hline
	Y & Utiliza o cálculo da forma esférica \\ \hline
	U & Utiliza o cálculo geral da anisotropia fracionada \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Grade (eixos cartesianos)}} \\ \hline
	G & Mostra/esconde a grade \\ \hline
	\multicolumn{2}{|p{11cm}|}{\textbf{Rampa de cores}} \\ \hline
	F & Alterna entre as rampas de cores disponíveis \\ \hline
	\end{longtable}
\end{center}

Além da interação com o teclado é possível rotacionar o campo utilizando o mouse. O movimento se inicia com o clique do botão esquerdo do mouse e termina quando o botão é solto.

\subsection{Exemplo de código}

A seguir será explicada a utilização básica da Pandora's Box. O exemplo desenvolvido utiliza um modelo de uma esfera que é transformada em um elipsóide no vertex shader. Inicialmente é incluído o header da engine:

\begin{verbatim}
#include "pbge/pbge.h"
\end{verbatim}

Na função \texttt{main} são definidas as configurações da janela (título e dimensões), associado um inicializador de cena customizado ao gerenciador de janelas e então é enviado o sinal para a engine iniciar a renderização das imagens na janela. É necessário que o usuário implemente um \texttt{SceneInitializer} que definirá a estrutura do grafo de cena.

\begin{verbatim}
int main() {
    pbge::Manager manager;
    MySceneInitializer sceneInitializer;
    manager.setWindowTitle("Ellipsoid demo");
    manager.setWindowDimensions(1024, 768);
    manager.setSceneInitializer(&sceneInitializer);
    manager.displayGraphics();
    return 0;
}
\end{verbatim}

O inicializador de cena deve herdar de \texttt{SceneInitializer} e implementar o operador \texttt{()}. É possível ter acesso ao renderizador através da instância de \texttt{Window} recebida como argumento. São então adicionados no renderizador os processadores de cena (\texttt{RenderPassProcessor}  e \texttt{BlitToFramebuffer}). Em seguida é criado o grafo de cena com um nó de transformação identidade como raíz. O grafo é então preenchido com outros nós e devolvido.

\begin{verbatim}
class MySceneInitializer : public pbge::SceneInitializer {
public:
    pbge::SceneGraph * operator () (pbge::GraphicAPI * gfx, pbge::Window * window) {
        pbge::Renderer * renderer = window->getRenderer();
        renderer->addSceneProcessor(new pbge::RenderPassProcessor);
        renderer->addPostProcessor(new pbge::BlitToFramebuffer);
        pbge::Node * root = new pbge::TransformationNode;
        pbge::SceneGraph * graph = new pbge::SceneGraph(root);
        
        configureCamera(root, gfx);
        createModel(root, gfx);

        return graph;
    }

private:
    void configureCamera(pbge::Node * parent, pbge::GraphicAPI * gfx) {...}
    void createModel(pbge::Node * parent, pbge::GraphicAPI * gfx) {...}
};
\end{verbatim}

Para definir a posição da câmera utiliza-se um nó de transformação linear que é adicionado como filho da raíz. A câmera é instanciada, configurada (direção e perspectiva) e adicionada aos filhos da transformação.

\begin{verbatim}
void configureCamera(pbge::Node * parent, pbge::GraphicAPI * gfx) {
    pbge::TransformationNode * cameraParent = 
                      pbge::TransformationNode::translation(0, 0, 10);
    pbge::CameraNode * camera = new pbge::CameraNode;
    camera->lookAt(math3d::vector4(0,1,0), math3d::vector4(0, 0, -1));
    camera->setPerspective(90, 1.0f, 2.0f, 30.0f);
    cameraParent->addChild(camera);
    parent->addChild(cameraParent);
}
\end{verbatim}

A esfera utilizada possui raio 2 e 100 subdivisões. O nó de modelo (\texttt{ModelInstance}) é criado a partir do modelo da esfera. O shader criado é adicionado ao nó, que é então adicionado ao grafo.

\begin{verbatim}
void createModel(pbge::Node * parent, pbge::GraphicAPI * gfx) {
    pbge::VBOModel * sphere = pbge::Geometrics::createSphere(2,100,gfx);
    pbge::ModelInstance * model = new pbge::ModelInstance(sphere);
    pbge::GPUProgram * shader = gfx->getFactory()->createProgramFromString(
        "#version 150\n"
        "in vec4 pbge_Vertex;\n"
        "out vec4 color\n;"
        "uniform mat4 pbge_ModelViewProjectionMatrix;\n"
        "void main() {\n"
        "   mat4 scale = mat4(1,0,0,0,\n"
        "                     0,2,0,0,\n"
        "                     0,0,1,0,\n"
        "                     0,0,0,1);\n"
        "   gl_Position = pbge_ModelViewProjectionMatrix*scale*pbge_Vertex;\n"
        "   color = vec4(pbge_Vertex.xyz, 1);\n"
        "}",
        "in vec4 color;\n"
        "void main() {\n"
        "   gl_FragColor = color;\n"
        "}"
        );
    model->setRenderPassProgram(shader);
    parent->addChild(model);
}
\end{verbatim}

O método \texttt{createProgramFromString} recebe duas strings, sendo a primeira o código do vertex shader e a segunda do fragment shader. Nesse exemplo o vertex shader definido recebe o vértice e a matriz ModelViewProjection e devolve a cor do fragmento. É criada uma matriz de escala que multiplica o vértice e o resultado é por sua vez multiplicado pela ModelViewProjection resultando na posição. A cor definida utiliza as coordenadas \texttt{x,y,z} como componentes \texttt{r,g,b}. O fragment shader define a cor do fragmento como a cor recebida do vertex shader.
