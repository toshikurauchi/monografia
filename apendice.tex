\appendix
\section{Apêndice}

\subsection{A Windows API}
\label{criacaojanela}
Para se inicializar um contexto para a execução de programas em OpenGL é
necessário criar uma janela, para isso utiliza-se a seguinte função:

\begin{codigo}
HWND WINAPI CreateWindow(
  __in_opt  LPCTSTR lpClassName,
  __in_opt  LPCTSTR lpWindowName,
  __in      DWORD dwStyle,
  __in      int x,
  __in      int y,
  __in      int nWidth,
  __in      int nHeight,
  __in_opt  HWND hWndParent,
  __in_opt  HMENU hMenu,
  __in_opt  HINSTANCE hInstance,
  __in_opt  LPVOID lpParam
);
\end{codigo}

Onde:
\begin{itemize}
\item \texttt{lpClassName}: representa uma classe registrada anteriormente no sistema.
\item \texttt{lpWindowName}: representa o título da janela.
\item \texttt{dwStyle}: conjunto de flags que definem o estilo da janela.
exibida: com bordas, maximizada, minimizada, etc.
\item \texttt{x, y}: posição inicial da janela.
\item \texttt{nWidth, nHeight}: dimensões iniciais da janela.
\item \texttt{hWndParent}: se a janela que está sendo criada é uma subjanela de uma já existente, 
  passa-se o handle (tipo especial de ponteiro inteligente) da janela pai nesse
  argumento, caso contrário, passa-se \texttt{NULL}.
\item \texttt{hMenu}: se for necessário criar uma menu, deve-se passar o handle do menu 
  nesse argumento, caso contrário, passa-se \texttt{NULL}.
\item \texttt{hInstance}: o handle da instância do programa que está sendo executado, 
  esse parâmetro é utilizado dentro do sistema para a criação de um
  identificador único para a janela.
\item \texttt{lpParam}: dados do usuário. Esse parâmetro recebe um ponteiro para qualquer 
  tipo de dado que o usuário necessite.
\end{itemize}

Para se registrar uma classe no sistema deve-se chamar a
função:

\begin{codigo}
ATOM WINAPI RegisterClass(
  __in  const WNDCLASS *lpWndClass
);
\end{codigo}

O argumento \texttt{lpWndClass} um ponteiro para uma instância de
\texttt{WNDCLASS}, uma estrutura que guarda, entre outras
coisas, o nome da classe que está sendo registrada, o ponteiro para a função que
irá tratar os eventos gerados pelo sistema e uma flag que indica se o contexto do 
dispositivo pode ser compartilhado. Quando se cria um contexto do OpenGL é importante 
sempre registrar a classe como dona do contexto do dispositivo.

Após criada, deve-se avisar o sistema que a janela é visível, para isso, executa-se:

\begin{codigo}
BOOL WINAPI ShowWindow(
  __in  HWND hWnd,
  __in  int nCmdShow
);
\end{codigo}

Onde \texttt{hWnd} é o handle devolvido pela função \texttt{CreateWindow} e \texttt{nCmdShow} 
controla como a janela deve ser exibida (maximizada, minimizada, simplesmente exibida, etc)

Após todo esse processo, pode-se consultar as mensagens recebidas pela janela
através da função:

\begin{codigo}
BOOL WINAPI GetMessage(
  __out     LPMSG lpMsg,
  __in_opt  HWND hWnd,
  __in      UINT wMsgFilterMin,
  __in      UINT wMsgFilterMax
);
\end{codigo}

Que recebe como parâmetros um ponteiro para uma estrutura do tipo
\texttt{MSG}, o handle devolvido pela função \texttt{CreateWindow}, \texttt{wMsgFilterMin} e \texttt{wMsgFilterMax} 
são constantes que podem ser passadas para indicar que tipo de mensagem deve ser retornada. O valor de retorno dessa 
função é um inteiro que indica qual o tipo de mensagem foi retornada ou se ocorreu um erro durante a execução da função.

Após recuperar a mensagem ela precisa ser traduzida e em seguida enviada para o seu destino final. 
A função responsável pela tradução da mensagem é:

\begin{codigo}
BOOL WINAPI TranslateMessage(
  __in  const MSG *lpMsg
);
\end{codigo}

e a função que envia a mensagem para a janela é:

\begin{codigo}
LRESULT WINAPI DispatchMessage(
  __in  const MSG *lpmsg
);
\end{codigo}

Quando se recebe a mensagem \texttt{WM\_QUIT}, o retorno de \texttt{GetMessage}
é \texttt{0}, nesse momento a tradução e envio de mensagens deve parar e o programa 
deve apagar o registro da classe criada por \texttt{RegisterClass}. O registro é apagado pela função:

\begin{codigo}
BOOL WINAPI UnregisterClass(
  __in      LPCTSTR lpClassName,
  __in_opt  HINSTANCE hInstance
);
\end{codigo}

que recebe como argumentos o nome com o qual a classe foi registrada e a instância do programa que registrou a classe.

\vsection{O laço de eventos da janela}

A função registrada na WNDCLASS que tratará os eventos gerados pelo sistema deve ter a seguinte assinatura:

\begin{codigo}
LRESULT CALLBACK WindowProc(
  __in  HWND hwnd,
  __in  UINT uMsg,
  __in  WPARAM wParam,
  __in  LPARAM lParam
);
\end{codigo}

Nessa função, o argumento hwnd é o handle da janela corrente, uMsg é um inteiro sem sinal que codifica a mensagem 
recebida e os argumentos wParam e lParam são os parâmetros da mensagem.

Um laço de eventos típico para um programa em OpenGL tem a seguinte forma:

\begin{codigo}
LRESULT CALLBACK WindowProc(HWND hWnd, 
                            UINT msg, 
                            WPARAM wParam, 
                            LPARAM lParam){
    switch(msg) {
        case WM_CREATE: 
            // Inicialização do contexto de renderização
            // no caso da WM_CREATE o valor de lParam é um 
            // ponteiro para um struct do tipo CREATESTRUCT
            // que contém o ponteiro para os dados do usuário
            // passado na função CreateWindow
            
        case WM_DESTROY:
            // Liberação de recursos gráficos e deleção do 
            // contexto criado
        case WM_CLOSE:
            // O usuário clicou no botão de fechamento da janela
            // Então deve-se avisar para o sistema operacional 
            // que a aplicação deve ser encerrada.
            PostQuitMessage(0);
            break;
        case WM_PAINT:
            // O sistema requisitou a atualização da janela
            // à aplicação

            // Funções do wgl para limpar e renderizar
            wglSwapBuffers();
            // avisa ao sistema que o evento já foi 
            // completamente tratado
            return 0;
    }
    // Executa a rotina padrão para tratar o evento gerado
    return (DefWindowProc(hwnd, msg, wParam, lParam));
}
\end{codigo}

Ao receber \texttt{WM\_CREATE} a aplicação deve inicializar todos os recursos 
para que a janela possa ser utilizada. No caso da Pandora's Box utilizando OpenGL 
como API gráfica, deve-se inicializar o contexto de renderização que será utilizado.

A criação do contexto é gerenciada pela API do wgl, que é a implementação de OpenGL para o Windows. 
O contexto que será utilizado pela aplicação deve ser criado através da função
\texttt{wglCreateContext}:

\begin{codigo}
HGLRC WINAPI wglCreateContext(
  HDC hdc
);
\end{codigo}

Essa função tem como argumento o handle para o dispositivo utilizado pela janela. Tal handle pode ser obtido através da função GetDC:

\begin{codigo}
HDC GetDC(
  __in  HWND hWnd
);
\end{codigo}

Logo a criação do contexto pode ser feita pelo seguinte trecho de código:

\begin{codigo}
case WM_CREATE:
    HDC hDC = GetDC(hWnd);
    // indica quantos bits devem ser utilizados por pixel,
    // bits do depth buffer, entre outras coisas
    setPixelFormatDescriptor();
    HGLRC hglrc = wglCreateContext(hDC);
    wglMakeCurrent(hglrc);
    break;
\end{codigo}


\subsection{Uso dinâmico de DLLs}
\label{dllload}

Para se executar código presente em uma DLL, é necessário carregá-la durante a execução do 
programa. Através da windows API, pode-se abrir um arquivo DLL com a função \texttt{LoadLibrary}:

\begin{codigo}
HMODULE WINAPI LoadLibrary(
  __in  LPCTSTR lpFileName
);
\end{codigo}

essa função retorna o handle para a biblioteca carregada ou NULL caso tenha
ocorrido um erro. Se o carregamento for bem sucedido, pode-se utilizar o handle
obtido para procurar funções dentro da DLL.

Na windows API, a função que cuida da busca de ponteiros de função é a GetProcAddress

\begin{codigo}
FARPROC WINAPI GetProcAddress(
  __in  HMODULE hModule,
  __in  LPCSTR lpProcName
);
\end{codigo}

Essa função devolve um ponteiro genérico do tipo void* que precisa ser
transformado para um ponteiro de função.

Um detalhe importante do carregamento dinâmico de bibliotecas escritas em C++, é que 
para permitir o uso de namespaces, classes e sobrecarga de funções, o compilador da 
linguagem muda os nomes das funções geradas. Para evitar a mudança de nomes, as 
funções a serem exportadas devem ser declaradas da forma abaixo:

\begin{codigo}
extern "C" {
    // declaração das funções a serem exportadas.
}
\end{codigo}

Além disso, os compiladores podem exigir algum tipo de anotação nas funções que
devem ser exportadas. No caso do compilador da
Microsoft\textsuperscript{\textregistered}, a
declaração do protótipo da função deve ser
precedida por \texttt{\_\_declspec(dllexport)}, como no código abaixo:

\begin{codigo}
__declspec(dllexport) TipoDeRetorno nome_da_funcao(parametros);
\end{codigo}
