\appendix
\section{Apêndice}

\subsection{A Windows API}
\label{criacaojanela}
Para se inicializar um contexto para a execução de programas em OpenGL é necessário criar uma janela, para isso usa-se a seguinte função:

\begin{codigo}
HWND WINAPI CreateWindow(
  __in_opt  LPCTSTR lpClassName,
  __in_opt  LPCTSTR lpWindowName,
  __in      DWORD dwStyle,
  __in      int x,
  __in      int y,
  __in      int nWidth,
  __in      int nHeight,
  __in_opt  HWND hWndParent,
  __in_opt  HMENU hMenu,
  __in_opt  HINSTANCE hInstance,
  __in_opt  LPVOID lpParam
);
\end{codigo}

Onde:
\begin{itemize}
\item \texttt{lpClassName}: representa uma classe registrada anteriormente no sistema.
\item \texttt{lpWindowName}: representa o título da janela.
\item \texttt{dwStyle}: conjunto de flags que definem como a janela será
exibida~\cite{docwindowstyle}: com bordas, maximizada, minimizada, etc.
\item \texttt{x, y}: posição inicial da janela.
\item \texttt{nWidth, nHeight}: dimensões iniciais da janela.
\item \texttt{hWndParent}: se a janela que está sendo criada é uma subjanela de uma já existente, passa-se o handle (tipo especial de ponteiro inteligente) da janela pai nesse argumento, caso contrário, passa-se \texttt{NULL}. Para a engine gráfica, esse argumento sempre recebe o valor \texttt{NULL}.
\item \texttt{hMenu}: se for necessário criar uma menu, deve-se passar o handle do menu nesse argumento, caso contrário, passa-se \texttt{NULL}.
\item \texttt{hInstance}: o handle da instância do programa que está sendo executado, esse parâmetro é utilizado dentro do sistema na criação de um identificador único para a janela.
\item \texttt{lpParam}: dados do usuário. Esse parâmetro recebe um ponteiro para qualquer tipo de dado que o usuário necessite. Na engine esse argumento recebe o ponteiro para uma instância de uma classe interna que representa a janela do sistema.
\end{itemize}

Para se registrar uma classe no sistema deve-se chamar a
função:

\begin{codigo}
ATOM WINAPI RegisterClass(
  __in  const WNDCLASS *lpWndClass
);
\end{codigo}

O argumento \texttt{lpWndClass} um ponteiro para uma instância de
\texttt{WNDCLASS}, uma estrutura que guarda, entre outras
coisas, o nome da classe que está sendo registrada, o ponteiro para a função que
irá tratar os eventos gerados pelo sistema e uma flag que indica se o contexto do dispositivo pode ser compartilhado. Quando se cria um contexto do OpenGL é importante sempre registrar a classe como dona do contexto do dispositivo. %TODO: Por que isso?

Após criada, deve-se avisar o sistema que a janela é visível, para isso, executa-se:

\begin{codigo}
BOOL WINAPI ShowWindow(
  __in  HWND hWnd,
  __in  int nCmdShow
);
\end{codigo}

Onde \texttt{hWnd} é o handle devolvido pela função \texttt{CreateWindow} e \texttt{nCmdShow} controla como a janela deve ser exibida (maximizada, minimizada, simplesmente exibida, etc)

% TODO: Em nenhum lugar foi citado que o trabalho é dividido em threads
Depois de criar a janela, a thread mãe começa a receber os eventos da janela criada em sua fila de mensagens. Para se recuperar uma mensagem da fila, utiliza-se a função:

\begin{codigo}
BOOL WINAPI GetMessage(
  __out     LPMSG lpMsg,
  __in_opt  HWND hWnd,
  __in      UINT wMsgFilterMin,
  __in      UINT wMsgFilterMax
);
\end{codigo}

Que recebe como parâmetros um ponteiro para uma estrutura do tipo
\texttt{MSG}~\cite{docmsg}, o handle devolvido pela função \texttt{CreateWindow}, \texttt{wMsgFilterMin} e \texttt{wMsgFilterMax} são constantes que podem ser passadas para indicar que tipo de mensagem deve ser retornada. O valor de retorno dessa função é um inteiro que indica qual o tipo de mensagem foi retornada ou se ocorreu um erro durante a execução da função.

Após recuperar a mensagem ela precisa ser traduzida e em seguida enviada para o seu destino final. A função responsável pela tradução da mensagem é:

\begin{codigo}
BOOL WINAPI TranslateMessage(
  __in  const MSG *lpMsg
);
\end{codigo}

e a função que envia a mensagem para a janela é:

\begin{codigo}
LRESULT WINAPI DispatchMessage(
  __in  const MSG *lpmsg
);
\end{codigo}

Quando a thread principal recebe a mensagem \texttt{WM\_QUIT}, o retorno de \texttt{GetMessage} é \texttt{0}, nesse momento a tradução e envio de mensagens deve parar e o programa deve apagar o registro da classe criada por \texttt{RegisterClass}. O registro é apagado pela função:

\begin{codigo}
BOOL WINAPI UnregisterClass(
  __in      LPCTSTR lpClassName,
  __in_opt  HINSTANCE hInstance
);
\end{codigo}

que recebe como argumentos o nome com o qual a classe foi registrada e a instância do programa que registrou a classe.

\vsection{O loop de eventos da janela}

A função registrada na WNDCLASS que tratará os eventos gerados pelo sistema deve ter a seguinte assinatura:

\begin{codigo}
LRESULT CALLBACK WindowProc(
  __in  HWND hwnd,
  __in  UINT uMsg,
  __in  WPARAM wParam,
  __in  LPARAM lParam
);
\end{codigo}

Nessa função, o argumento hwnd é o handle da janela corrente, uMsg é um inteiro sem sinal que codifica a mensagem recebida e os argumentos wParam e lParam são os parâmetros da mensagem.

Por exemplo:
% falar sobre window resize...

Um laço de eventos típico para um programa em OpenGL tem a seguinte forma:

\begin{codigo}
LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg) {
        case WM_CREATE: 
            // Inicialização do contexto de renderização
            // no caso da WM_CREATE o valor de lParam é um 
            // ponteiro para um struct do tipo CREATESTRUCT
            // que contém o ponteiro para os dados do usuário
            // passado na função CreateWindow
            
        case WM_DESTROY:
            // Liberação de recursos gráficos e deleção do 
            // contexto criado
        case WM_CLOSE:
            // O usuário clicou no botão de fechamento da janela
            // Então deve-se avisar para o sistema operacional 
            // que a aplicação deve ser encerrada.
            PostQuitMessage(0);
            break;
        case WM_PAINT:
            // O sistema requisitou à aplicação a atualização da janela

            // Funções do OpenGL para limpar e renderizar
            wglSwapBuffers();
            // avisa ao sistema que o evento já foi completamente tratado
            return 0;
    }
    // Executa a rotina padrão para tratar o evento gerado
    return (DefWindowProc(hwnd, msg, wParam, lParam));
}
\end{codigo}

Ao receber \texttt{WM\_CREATE} a aplicação deve inicializar todos os recursos para que a janela possa ser utilizada. No caso da Pandora's Box utilizando OpenGL como API gráfica, deve-se inicializar o contexto de renderização que será utilizado.

% antes de chamarmos wglCreateContext devemos criar o pixel format descriptor
A criação do contexto é gerenciada pela API do wgl (também conhecido como Wiggle), que é a implementação de OpenGL para o Windows. O contexto que será utilizado pela aplicação deve ser criado através da função wglCreateContext:

% assinatura da wglCreateContext
\begin{codigo}
\end{codigo}

Essa função tem como argumento o handle para o dispositivo utilizado pela janela. Tal handle pode ser obtido através da função GetDC:

% outro prototipo
% Verificar se precisa do prototipo ou tirar o : anterior

Logo a criação do contexto pode ser feita pelo seguinte trecho de código:

\begin{codigo}
case WM_CREATE:
    HDC hDC = GetDC(hWnd);
    setPixelFormatDescriptor();
    HGLRC hglrc = wglCreateContext(hDC);
    wglMakeCurrent(hglrc);
    break;
\end{codigo}


\subsection{Uso dinâmico de DLLs}
\label{dllload}

Para se executar código presente em uma DLL, é necessário carregá-la durante a execução do 
programa. Através da windows API, pode-se abrir um arquivo DLL com a função \texttt{LoadLibrary}:

\begin{codigo}
% protótipo da load library
\end{codigo}

essa função retorna o handle para a biblioteca carregada ou NULL caso tenha ocorrido um erro. Caso o carregamento seja bem sucedido, pode-se utilizar o handle obtido para procurar ponteiro de funções.

Na windows API, a função que cuida da busca de ponteiros de função é a GetProcAddress

\begin{codigo}
% protótipo da get proc address
\end{codigo}

essa função devolve um ponteiro genérico do tipo void* que precisa ser transformado para um ponteiro de função.

% Verificar esse paragrafo (explicar melhor, ligar com o resto)
O carregamento de uma DLL dynamic\_create.dll com uma função chamada create é exemplificado no código abaixo:

\begin{codigo}
// função que não recebe argumentos e retorna um ponteiro genérico
typedef void * (__cdecl * MYPROC)();

HINSTANCE lib = LoadLibrary(L"dynamic_create.dll");
MYPROC lib_create = (MYPROC)GetProcAddress(lib, L"create");
SomeObject object = (SomeObject) lib_create();
\end{codigo}

Um detalhe importante do carregamento dinâmico de bibliotecas escritas em C++, é que para permitir o uso de namespaces, classes e sobrecarga de funções, o compilador da linguagem muda os nomes das funções geradas. Logo se uma função chamada create for compilada como um procedimento de C++, seu nome no arquivo dll não será create, mas sim um nome que depende da implementação do compilador utilizado. Para evitar a mudança de nomes, as funções a serem exportadas devem ser declaradas da forma abaixo:

\begin{codigo}
extern "C" {
    // declaração das funções a serem exportadas.
}
\end{codigo}

Outro detalhe específico do compilador da Microsoft, que foi utilizado nesse trabalho, é que os procedimentos que serão exportados devem ser definidos com a diretiva da seguinte forma:
\begin{codigo}
__declspec(dllexport) TipoDeRetorno nome_da_funcao(parametros);
\end{codigo}
